归并排序基本原理是将两个有序的数组，在合并的过程中进行排序成一个更大的有序数组。
归并排序的时间复杂度为NlogN，缺点是需要额外的内存空间

归并排序的实现方法是：创建一个适当大小的数组然后将两个输入数组中的元素一个个从小到大的放入这个数组中。

将两个数组抽象化的归并方法如下：
方法名为merge（a,lo,mid,hi），它会将子数组a[lo...mid]  a[mid+1...hi]归并成一个有序的数组并将结果存放在a[lo...hi]中，

public static void merge(Comparable[] a, int lo, int mid, int hi){  
//将a[lo...mid]  和a[mid+1...hi]归并  
    int i = lo;   // 第一个有序区域的索引   
    int j = mid +1;  //第二个有序区域的索引  
      
    for(int k = lo; k <= hi; k++){//将a[lo...hi]复制到aux[lo...hi]中，这样在操作a[]是数据不会被覆盖而丢  
        aux[k] = a[k];            //aux[]   是在类中建立的一个辅助数组，它的大小和a[]的大小一样大  
    }  
      
    for(int k = lo; k <=hi; k++){  //归并到a[lo...hi]中  
        if(i > mid){            //左半边用尽，也就是当第一个有序数组的所有数据都放入到归并的数组中了，由于上一次结果会i++，  
                                //所以会进入到这个条件中，那就直接把右边的往归并数组里扔就可以了  
            a[k] = aux[j++];  
        }else if(j > hi){       //同上，当右半边数据（第二个有序区域）都放入到归并的数组中了，那就直接吧剩下的左边数据（第一个有序数组）放入归并数组  
            a[k] = aux[i++];  
        }else if(less(aux[j], aux[i])){//这句话才是归并在比较大小的那句，谁小谁放入数组中  
            a[k] = aux[j++];  
        }else{  
            a[k] = aux[i++];  
        }  
    }  
}  

归并排序一共有两种方法，一种是自上而下的归并排序，一种是自下而上的归并排序
（1）自下而上的归并排序
所谓的自下而上排序分为三个步骤
1.分解：将待排序的数列分成若干个长度为1的子数列，然后将这些数列两两合并；
2.合并：得到若干个长度为2的有序数列，再将这些数列两两合并；
3.递归：得到若干个长度为4的有序数列，再将它们两两合并；直接合并成一个数列为止。这样就得到了我们想要的排序结果。

通过"从下往上的归并排序"来对数组{80,30,60,40,20,10,50,70}进行排序时：
1. 将数组{80,30,60,40,20,10,50,70}看作由8个有序的子数组{80},{30},{60},{40},{20},{10},{50}和{70}组成。
2. 将这8个有序的子数列两两合并。得到4个有序的子树列{30,80},{40,60},{10,20}和{50,70}。
3. 将这4个有序的子数列两两合并。得到2个有序的子树列{30,40,60,80}和{10,20,50,70}。
4. 将这2个有序的子数列两两合并。得到1个有序的子树列{10,20,30,40,50,60,70,80}。

具体代码实现如下：
public class Down2UpMerge {  
    private static Comparable[] aux;  //归并所需的辅助数组  
    public static void sort(Comparable[] a){  
        //进行lgN次来两两归并  
        int N = a.length;  
        aux = new Comparable[N];  
        for (int sz = 1; sz < N; sz = sz +sz) {  //sz：子数组的大小, sz成2的幂次方增长  
            for(int lo = 0; lo < N-sz; lo += sz+sz){//lo:子数组的索引，  sz=1时，子数组有2个数，sz=2时，子数组有4个数，sz=4时，子数组有8个数  
                merge(a, lo, lo+sz-1, Math.min(lo+sz+sz-1, N-1));  
            }  
        }  
    }  
      
    public static void merge(Comparable[] a, int lo, int mid, int hi){  
        // 将a[lo...mid] 和a[mid+1...hi]归并  
        int i = lo; // 第一个有序区域的索引  
        int j = mid + 1; // 第二个有序区域的索引  
  
        for (int k = lo; k <= hi; k++) {// 将a[lo...hi]复制到aux[lo...hi]中，这样在操作a[]是数据不会被覆盖而丢  
            // aux[] 是在类中建立的一个辅助数组，它的大小和a[]的大小一样大  
            aux[k] = a[k];   
        }  
  
        for (int k = lo; k <= hi; k++) { // 归并到a[lo...hi]中  
            if (i > mid) { // 左半边用尽，也就是当第一个有序数组的所有数据都放入到归并的数组中了，由于上一次结果会i++，  
                            // 所以会进入到这个条件中，那就直接把右边的往归并数组里扔就可以了  
                a[k] = aux[j++];  
            } else if (j > hi) { // 同上，当右半边数据（第二个有序区域）都放入到归并的数组中了，那就直接吧剩下的左边数据（第一个有序数组）放入归并数组  
                a[k] = aux[i++];  
            } else if (less(aux[j], aux[i])) {// 这句话才是归并在比较大小的那句，谁小谁放入数组中  
                a[k] = aux[j++];  
            } else {  
                a[k] = aux[i++];  
            }  
        }  https://s.click.taobao.com/1nwweYw
    }  
  
}  

（2）自上而下归并排序
所谓的自上而下归并排序，它与"从下往上"在排序上是反方向的。它基本包括3步：
① 分解 -- 将当前区间一分为二，即求分裂点 mid = (low + high)/2; 
② 求解 -- 递归地对两个子区间a[low...mid] 和 a[mid+1...high]进行归并排序。递归的终结条件是子区间长度为1。
③ 合并 -- 将已排序的两个子区间a[low...mid]和 a[mid+1...high]归并为一个有序的区间a[low...high]。

通过"从上往下的归并排序"来对数组{80,30,60,40,20,10,50,70}进行排序时：
1. 将数组{80,30,60,40,20,10,50,70}看作由两个有序的子数组{80,30,60,40}和{20,10,50,70}组成。对两个有序子树组进行排序即可。
2. 将子数组{80,30,60,40}看作由两个有序的子数组{80,30}和{60,40}组成。
    将子数组{20,10,50,70}看作由两个有序的子数组{20,10}和{50,70}组成。
3. 将子数组{80,30}看作由两个有序的子数组{80}和{30}组成。
    将子数组{60,40}看作由两个有序的子数组{60}和{40}组成。
    将子数组{20,10}看作由两个有序的子数组{20}和{10}组成。
    将子数组{50,70}看作由两个有序的子数组{50}和{70}组成。

具体代码实现如下：
public static void sort(Comparable[] a){  
        aux = new Comparable[a.length];//一次性分配空间，aux是辅助数组  
        sort(a, 0, a.length-1);  
}  
private static void up2DownSort(Comparable[] a, int lo, int hi) {  
    // 将数组a[lo...hi]排序  
    if(hi <= lo)  
        return;  
    int mid = lo + (hi - lo)/2;  
    sort(a, lo, mid);    //将左半边排序  
    sort(a, mid+1, hi);  //将右半边排序  
    merge(a, lo, mid, hi);//归并结果（  
}  
public static void merge(Comparable[] a, int lo, int mid, int hi){  
    // 将a[lo...mid] 和a[mid+1...hi]归并  
    int i = lo; // 第一个有序区域的索引  
    int j = mid + 1; // 第二个有序区域的索引  
  
    for (int k = lo; k <= hi; k++) {// 将a[lo...hi]复制到aux[lo...hi]中，这样在操作a[]是数据不会被覆盖而丢  
        // aux[] 是在类中建立的一个辅助数组，它的大小和a[]的大小一样大  
        aux[k] = a[k];   
    }  
  
    for (int k = lo; k <= hi; k++) { // 归并到a[lo...hi]中  
        if (i > mid) { // 左半边用尽，也就是当第一个有序数组的所有数据都放入到归并的数组中了，由于上一次结果会i++，  
            // 所以会进入到这个条件中，那就直接把右边的往归并数组里扔就可以了  
            a[k] = aux[j++];  
        } else if (j > hi) { // 同上，当右半边数据（第二个有序区域）都放入到归并的数组中了，那就直接吧剩下的左边数据（第一个有序数组）放入归并数组  
            a[k] = aux[i++];  
        } else if (less(aux[j], aux[i])) {// 这句话才是归并在比较大小的那句，谁小谁放入数组中，此处的less（）函数时之前文章提到的  
            a[k] = aux[j++];  
        } else {  
            a[k] = aux[i++];  
        }  
    }  
}  


归并排序时间复杂度
归并排序的时间复杂度是O(N*lgN)。
假设被排序的数列中有N个数。遍历一趟的时间复杂度是O(N)，需要遍历多少次呢？
归并排序的形式就是一棵二叉树，它需要遍历的次数就是二叉树的深度，而根据完全二叉树的可以得出它的时间复杂度是O(N*lgN)。

归并排序稳定性
归并排序是稳定的算法，它满足稳定算法的定义。
算法稳定性 -- 假设在数列中存在a[i]=a[j]，若在排序之前，a[i]在a[j]前面；并且排序之后，a[i]仍然在a[j]前面。则这个排序算法是稳定的！


